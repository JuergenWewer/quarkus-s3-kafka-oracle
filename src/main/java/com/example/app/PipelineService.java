package com.example.app;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.jboss.logging.Logger;

import javax.sql.DataSource;
import java.net.URI;
import java.sql.*;
import java.time.Instant;
import java.util.UUID;

import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.*;

@ApplicationScoped
public class PipelineService {

    private static final Logger LOG = Logger.getLogger(PipelineService.class);

    @Inject DataSource dataSource;
    @Inject ObjectMapper mapper;
    @Channel("names-out") Emitter<String> out;
    @Inject S3Config s3Config;

    S3Client s3;
    String bucket;

    @PostConstruct
    void init() {
        s3 = S3Client.builder()
                .endpointOverride(URI.create(s3Config.endpoint()))
                .credentialsProvider(StaticCredentialsProvider.create(
                        AwsBasicCredentials.create(s3Config.accessKey(), s3Config.secretKey())))
                .region(Region.of(s3Config.region()))
                .forcePathStyle(true)
                .build();
        bucket = s3Config.bucket();
        try {
            s3.createBucket(CreateBucketRequest.builder().bucket(bucket).build());
        } catch (BucketAlreadyOwnedByYouException ignored) {
        } catch (Exception e) {
            LOG.warn("Bucket create: " + e.getMessage());
        }
        // ensure table exists
        try (Connection c = dataSource.getConnection(); Statement st = c.createStatement()) {
            st.executeUpdate("""
                BEGIN
                  EXECUTE IMMEDIATE 'CREATE TABLE names (
                    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    name VARCHAR2(255)
                  )';
                EXCEPTION WHEN OTHERS THEN
                  IF SQLCODE != -955 THEN RAISE; END IF;
                END;
            """);
        } catch (Exception e) {
            LOG.warn("Table init: " + e.getMessage());
        }
    }

    @Incoming("names-in")
    public void onMessage(String json) {
        try {
            JsonNode node = mapper.readTree(json);
            String name = node.hasNonNull("name") ? node.get("name").asText() : null;
            if (name == null || name.isBlank()) {
                LOG.warn("Invalid payload: " + json);
                return;
            }

            // 1) save json to S3
            String key = "names/" + Instant.now().toEpochMilli() + "-" + UUID.randomUUID() + ".json";
            s3.putObject(
              PutObjectRequest.builder()
                .bucket(bucket)
                .key(key)
                .build(),
              RequestBody.fromString(json)
            );

            // 2) insert name and fetch id (ohne RETURN_GENERATED_KEYS)
            long id;
            try (Connection c = dataSource.getConnection()) {

                // 2a) Datensatz einf√ºgen
                try (PreparedStatement ps = c.prepareStatement("INSERT INTO names (name) VALUES (?)")) {
                    ps.setString(1, name);
                    ps.executeUpdate();
                }

                // 2b) ID ermitteln
                try (Statement st = c.createStatement();
                     ResultSet rs = st.executeQuery("SELECT MAX(id) FROM names")) {
                    if (rs.next()) {
                        id = rs.getLong(1);
                    } else {
                        LOG.error("No ID returned from SELECT MAX(id) FROM names");
                        return;
                    }
                }
            }

            // 3) emit id
            out.send(Long.toString(id));
        } catch (Exception e) {
            LOG.error("Processing failed", e);
        }
    }
}